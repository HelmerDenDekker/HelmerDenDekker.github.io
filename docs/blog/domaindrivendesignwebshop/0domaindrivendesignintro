# 0 Domain-driven design: Introduction
*10-7-2023*

Everything starts at zero, right? In the aftermath of designing the webshop, I became aware of some thing(s) missing. First I will tell you a story.

## Context of Domain-driven design

I mean, why do this? I started my journey in web design in 2001, creating some webpage in Microsoft FrontPage (which was mandatory for that course...). I screamed in agony. So instead I wrote my own stuff in notepad, using HTML and CSS. Later I escaped to dreamweaver, which was a bit better. 
Why telling you these stories? Because I know I wanted to tell other people about all of the crazy stuff I was doing with MATLAB. So I knew what I wanted it to look like.

### Design starts at Frontend

At that time web technology (for me) was about the looks. We now know this as "frontend". All of my subsequent designs, including those for Xerbutri were started from sketches of what the pages would look like.

My designs were developed in the following order:

::: Frontend-first
Frontend -> controllers -> logic -> infra -> database
:::

The controllers are MVC-controllers. Frontend were HTML-templates (the view of MVC).

At first the guys from Xerbutri and some other smaller pages were happy. Because you can deliver very fast, having to dive into the piping later. So at first they were happy, later a bit less happy since resolving bugs could take a long time.

### A real job! Start the design from the database

As I found my first job, the way of working in the company was to start with the database design, because storing and retrieving data was slowest. Having this piece optimized was giving large gains in performance. Remember, this was the webforms/MVC era. So performance-wise backend-to-frontend was a non-issue.

Starting with the database meant a long time-to-market, because my normal way of designing was inverted:

::: Database-first
Database -> infra -> logic -> controllers -> frontend.
:::

The first months were spent with determining database design, normalization, datatypes, models and lots of discussions about optimization.

### A real job! Calculation services

As I started with my first design of a calulation module, I just couldn't handle the data-driven way off working, so I went back to the way of working as I learned at the University. First define your problem-domain.

::: Start with the logic
Logic
:::

And now what? Let's first show the results to the user. Because I had to convince the guys my tool was working right? So I build this orchestrator and called it a service.

::: Next define an orchestrator
Service -> Logic
:::

How to show this in the front end? That is quite easy, right?
::: Next define an orchestrator
Frontend -> Controllers -> Service
:::
Now Helmer, how should we save the stuff calculated? Because your calculation is quite slow (HTTP-call!) and we want some caching of some sort. 'Let's use the database for that!', they shouted thrilled. And so the guys started building models and the database (with Entity Framework this time, which made me quite happy).

::: Next define an orchestrator
Frontend -> Controllers -> Infra -> Database
AND
Frontend -> Controllers -> Service -> Logic
:::

It was nice to be able to show our users real calculation results (no matter how "slow" they were) in a shorter time than normal.
In the following month we could bring updates to the users increasing performance bit by bit.

### Domain-driven design

In the course I followed, the teacher (what is it called??) told us about Domain-driven design.

#### Start your design in the middle
Domain driven design is a software design approach starting with the Domain.
Wait! I know that from my calculation services! However, there is a bit more.

#### Ubiquitous

We have all heard that difficult word, right? I always have to look up how to write it. Do not ask me how to pronounce it! The meaning of the word: being clear, existing, or being everywhere. A bit like God. Right? Or not?
I know this! The language in the code uses the language as used in the domain. As I was well aware of in my calculation modules. I mentioned the equation numbers in my methods.

And we used to do this all of the time. Because otherwise the domain experts did not know what we talked about. 
However, because of the universal containing-all-and-true-everywhere data model, fights used to break out. Because one domain expert was talking about User, the other one was talking about Customer, etc. The experts were demanding changes to model not agreed by others, it quickly became one big ball of spaghetti-mud. 

Which brings us to the next topic I think is most important:

#### Rich versus Anemic domain models

Because of being data-driven programmers, and brought up with these abstract problem solving methodologies using object oriented software designs (Are you still following? I lost myself here!). So instead they found a word to describe this situation: Rich domain models.

Not only were our models rich, they were also abstracted to the maximum for the best reuseability, because that is the ultimate goal. Write one application to rule them all!!

The thing is having this one application for a thousand things means it is good at nothing, and really, really hard to change.

This is where domain-driven design kicks in. We humans are not good at making these big universal truth applications, which contain all the information. So why not do the complete opposite: Have an anemic domain model?

So instead of having as many relations as possible, what is the minimum amount of relations the domain expert is happy with?

#### Isolation

I think the last important property of domain-driven design is isolation.

The Domain layer is for the Domain experts, business logic, entities, value objects and aggregates.
The Presentation layer is for the users.
The Infrastructure layer is for persistance of data and integration to other services.

The Application layer connects the different layers with eachother.

These layers live in isolation, and have interfaces to talk to each other.















